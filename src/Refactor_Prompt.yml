Objective and Scope:
  - I have a complex codebase that needs refactoring. Here's what I'd like your help with:

Refactoring Goals:

1. Code Organization:
   - Split device types from HE_DeviceCharacteristics.js into individual files
   - Place new the device type files in src/devices_types/ folder
   - Create a base class for all device types to extend
   - We don't need to create a complicated folder structure for this plugin so just use a flat folder structure with the exception of the devices_types folder
   - the devices_types folder should have a file for each device type in a flat folder structure
   

2. Create a HubitatAccessory Class Implementation:
   - Should contain common functions across device types:
     - handle all interactions the PlatformAccessory object called accessory
     - Accessory initialization
     - AccessoryInfo assignment 
     - getOrAddService
     - hasCapability
     - hasService
     - getCharacteristic
     - any Other shared utility functions necessary

3. Device Type Handling:
   - Move service/characteristic logic to individual device files
   - use the device type id as the file name 
   - Properly handle special services:
     - Buttons
     - Lights (including adaptive lighting)
   - Maintain service/characteristic cleanup logic.
   - handle each device type's specific logic in their respective files like the transforms, adaptive lighting, etc.

4. File Cleanup:
   - Eliminate HE_DeviceCharacteristics.js file
   - Eliminate Transforms file

5. Function Cleanup:
   - Eliminate manageGetCharacteristic
   - Eliminate manageGetSetCharacteristic


# 5. Resource usage optimizations:
#   - optimize memory and cpu resource consumption 
#    - Eliminate the use of global variables
#    - Eliminate the use of the Utils class

Output Expectations:
  - Step 1: Let's create a plan and outline the steps we need to take to refactor the code.
  - Step 2: Please provide the refactored code for the device types and any other necessary changes (one file at a time to avoid going over the response limit).


I need help refactoring code from these source files into a new architecture. The files are:
- HE_ServiceTypes.js - Contains device type detection logic and service mapping
- HE_Transforms.js - Contains value transformation logic
- HE_DeviceCharacteristics.js - Contains device type implementations
- HE_Accessories.js - Main accessory handling
- HE_Platform.js - Platform initialization and management
- HE_Client.js - Contains the axios logic for interfacing with hubitat hub (code not included)

I want to refactor into:

- HubitatPlatformAccessory.js Core Functions:
  - constructor(platform, accessory) - Initialize base accessory functionality
  - initializeAccessory() - Setup basic accessory services
  - configureAccessoryInfo() - Configure accessory information service
  - getOrAddService(serviceType, name, subType) - Get or create services
  - getOrAddCharacteristic(service, characteristicType, options = {}) - Get or create characteristics
    example: getOrAddCharacteristic(service, characteristicType, options = {}) {
        const { preReqChk = null, getHandler = null, setHandler = null, props = {}, eventOnly = true } = options;

        if (preReqChk && !preReqChk(this.accessory)) {
            return null;
        }

        let characteristic = service.getCharacteristic(characteristicType) || service.addCharacteristic(characteristicType);

        if (this.isButtonDevice()) {
            this.platform.logDebug(`${this.accessory.displayName} (Button) | Adding/Getting characteristic: ${characteristicType.name} for service: ${service.UUID}`);
        }

        if (Object.keys(props).length > 0) {
            characteristic.setProps(props);
        }

        if (!eventOnly) {
            characteristic.eventOnlyCharacteristic = false;
        }

        if (getHandler) {
            characteristic.onGet(getHandler.bind(this.accessory));
        }

        if (setHandler) {
            characteristic.onSet(setHandler.bind(this.accessory));
        }

        return characteristic;
    }

    in the device type files would be something like this:
    this.accessory.getOrAddCharacteristic(this.motionSvc, this.Characteristic.StatusTampered, {
            preReqChk: () => this.hasCapability("TamperAlert"),
            getHandler: () => {
                const isTampered = this.deviceData.attributes.tamper === "detected";
                this.log.debug(`${this.accessory.displayName} | Status Tampered Retrieved: ${isTampered}`);
                return isTampered;
            },
            removeIfMissingPreReq: true,
        });
  - setupCharacteristicGet() - Setup get handlers for characteristics
  - setupCharacteristicGetSet() - Setup get/set handlers for characteristics
  - markServiceForRetention() - Mark services to keep during cleanup
  - cleanupUnusedServices() - Remove unused services
  - sendCommand() - Handle command debouncing and execution
  - handleAttributeUpdate() - Process attribute updates
  - hasCapability(), hasAttribute(), hasCommand(), and any other relevant functions
  - we need to maintain a separate object for services and characteristics to retain so they are not removed during cleanup (something like this.activeServices = new Set())
  

- HubitatAccessories.js Core Functions:

  - constructor(platform) - Initialize with device type tests array
  - initializeAccessory() - Create appropriate device type instances
  - determineDeviceTypes() - Test accessory against device type patterns
  - include the service tests in with a format like this:
    this.deviceTypeTests = [
            {
                name: "window_covering",
                test: (accessory) => accessory.hasCapability("WindowShade"),
                class: WindowCovering,
            },
            {
                name: "light",
                test: (accessory) =>
                    accessory.hasCapability("Switch") &&
                    (accessory.hasCapability("LightBulb") || accessory.hasCapability("Bulb") || (this.config.consider_light_by_name && accessory.context.deviceData.name.toLowerCase().includes("light")) || ["saturation", "hue", "colorTemperature"].some((attr) => accessory.hasAttribute(attr)) || accessory.hasCapability("ColorControl")),
                class: Light,
            },
            {
                name: "air_purifier",
                test: (accessory) => accessory.hasCapability("custom.airPurifierOperationMode"),
                class: AirPurifier,
                disable: true,
            },
          ]

          // Reorder deviceTypeTests so that entries with 'onlyOnNoGrps: true' are at the end
        this.deviceTypeTests.sort((a, b) => {
            if (a.onlyOnNoGrps && !b.onlyOnNoGrps) return 1;
            if (!a.onlyOnNoGrps && b.onlyOnNoGrps) return -1;
            return 0;
        });

        async getDeviceTypes(accessory) {
        const matchedTypes = [];

        for (const deviceTest of this.deviceTypeTests) {
            if (!deviceTest.disable && deviceTest.test(accessory)) {
                if (deviceTest.excludeDevTypes && deviceTest.excludeDevTypes.some((devType) => matchedTypes.some((m) => m.name === devType))) {
                    continue;
                }
                matchedTypes.push({
                    name: deviceTest.name,
                    class: deviceTest.class,
                });
            }
        }

        if (accessory.isButtonDevice()) {
            this.log.info(`${accessory.name} | Device types found: ${matchedTypes.map((t) => t.name)}`);
        }
        return matchedTypes;
    }
  - processDeviceAttributeUpdate() - Route updates to correct handlers
  - registerAttributeHandlers() - Setup attribute update routing
  - cleanupAccessory() - Handle accessory removal/cleanup

  - We need to maintain the accessories in the accessories as a new set() so it's better to use the set() methods for adding and removing accessories with async.

- Device Types (in device_types folder): Each extends HubitatPlatformAccessory and implements:
  - configureServices() - Setup device-specific services
  - handleAttributeUpdate() - Handle device-specific updates
  - Any device-specific helper methods like transforms, adaptive lighting, etc.

The core goals are:
  - Support multiple device types per accessory
  - Proper cleanup of unused services/characteristics
  - Maintain all existing functionality
  - Better organization and maintainability

Please help refactor using these patterns.